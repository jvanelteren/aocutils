# AUTOGENERATED! DO NOT EDIT! File to edit: ../03_math.ipynb.

# %% auto 0
__all__ = ['factors', 'gcd', 'lcm', 'crt', 'mul_inv', 'Segment', 'lis', 'angle', 'all_combinations', 'all_permutations', 'mst']

# %% ../03_math.ipynb 2
from functools import reduce
import operator
import heapq
from math import sqrt, gcd
import math
from bisect import bisect_left
from itertools import combinations, permutations, chain
from aocutils.special import UnionFind

# %% ../03_math.ipynb 3
def factors(n):
    """
    return set of divisors of a number
    """
    step = 2 if n % 2 else 1
    return set(
        reduce(
            list.__add__,
            ([i, n // i] for i in range(1, int(sqrt(n)) + 1, step) if n % i == 0),
        )
    )

# %% ../03_math.ipynb 5
def gcd(a, b):
    largest = max(a, b)
    smallest = min(a, b)
    if a == b:
        return a
    if not largest % smallest:
        return smallest
    while True:
        rest = largest % smallest
        if rest == 0:
            return prevrest
        else:
            prevrest = rest
            largest = smallest
            smallest = rest


def lcm(a):
    lcm = a[0]
    for i in a[1:]:
        lcm = lcm * i // gcd(lcm, i)
    return lcm

# %% ../03_math.ipynb 8
def crt(remainders, moduli):
    """
    Chinese remainder theorem
    """
    cur_rem = remainders[0]
    cur_mod = moduli[0]
    for rem, mod in zip(remainders[1:], moduli[1:]):
        i = 0
        while True:
            if (cur_rem + i * cur_mod) % mod == rem % mod:
                cur_rem += i * cur_mod
                cur_mod = lcm((cur_mod, mod))
                break
            else:
                i += 1
    print("Returning remainder and modulo. First valid number is the remainder")
    return cur_rem, cur_mod

# %% ../03_math.ipynb 13
def mul_inv(a, b):
    # solves e.g. 40x === 1(mod 7) --> 3
    # since 40-35 --> 5x === 1mod(7), if x would be 3, 15 === 1 (mod 7)
    # this is called the multiplicative inverse
    b0 = b
    x0, x1 = 0, 1
    if b == 1:
        return 1
    while a > 1:
        q = a // b
        a, b = b, a % b
        x0, x1 = x1 - q * x0, x0
    if x1 < 0:
        x1 += b0
    return x1

# %% ../03_math.ipynb 15
# first try at implementing a segment tree
class Segment:
    def __init__(self, array, func):
        self.length = len(array)
        self.func = func
        self.data = [0] * self.length + array

        for idx in range(self.length - 1, -1, -1):
            self.data[idx] = self.func(self.data[idx * 2], self.data[idx * 2 + 1])

    def update(self, idx, val):
        idx += self.length
        while idx > 0:
            self.data[idx] = self.func(self.data[idx], val)
            idx //= 2

    def __call__(self, leftidx, rightidx):
        self.query(leftidx, rightidx)

    def query(self, leftidx, rightidx):
        l = leftidx + self.length
        r = rightidx + self.length
        res = self.data[l]
        while l < r:
            if l % 2:
                res = self.func(res, self.data[l])
                l += 1

            if r % 2:
                res = self.func(res, self.data[r - 1])
                r -= 1
            l, r = l // 2, r // 2
        return res

# %% ../03_math.ipynb 20
def lis(nums, func=operator.ge):
    """
    Change the func to change it into longest decreasing subsequence. Or other
    Default is operator.ge, which represents longest strictly increasing subsequence
    """
    best = [1] * len(nums)
    bestidx = 0
    bestlength = 1
    parents = {i: False for i in range(len(nums))}
    ans = []
    for i in range(1, len(nums)):
        for j in range(i):
            if func(nums[i],nums[j]):
                if best[i] < best[j] + 1: # best[i] can be improved
                    best[i] = best[j] + 1
                    parents[i] = j
                    if best[i] > bestlength:
                        bestlength = best[i]
                        bestidx = i
    ans = [nums[bestidx]]
    while parents[bestidx] is not False:
        bestidx = parents[bestidx]
        ans.append(nums[bestidx])
    return list(reversed(ans)) 

# %% ../03_math.ipynb 21
def angle(a,b):
    dx = b[0] - a[0]
    dy = b[1] - a[1]
    return math.degrees(math.atan2(dx,dy))
    



# %% ../03_math.ipynb 24
def all_combinations(it, start=None, end=None):
    """
    Returns all combinations from start to end (inclusive).
    Defaults to 1, len(end)
    """
    if not start: start = 1
    if not end: end = len(it)
    assert 0 < start < len(it)
    assert start < end
    assert 0 < end <= len(it)
    for i in range(start, end + 1):
        for comb in combinations(it, i):
            yield comb

# %% ../03_math.ipynb 26
def all_permutations(it, start=None, end=None):
    if not start: start = 1
    if not end: end = len(it)
    assert 0 < start < len(it)
    assert start < end
    assert 0 < end <= len(it)
    for i in range(start, end + 1):
        for perm in permutations(it, i):
            yield perm

# %% ../03_math.ipynb 28
def mst(edges):
    # implements kruskall with unionfind
    edges.sort(key=lambda x: (-x[2]))
    nodes = set(chain.from_iterable([[a, b] for a, b, cost in edges]))
    uf = UnionFind(nodes)
    totalcost = 0
    while not uf.is_spanning() and edges:
        a, b, cost = edges.pop()
        if uf.get_parent(a) != uf.get_parent(b):
            uf.union(a, b)
            totalcost += cost
    
    return totalcost if uf.is_spanning() else False
