"""A collection of somewhat handy functions to make your AoC puzzle life solving a bit easier"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../02_maze.ipynb.

# %% auto 0
__all__ = ['graphparse', 'bfs', 'dijkstra', 'distances', 'get_path', 'dfs']

# %% ../02_maze.ipynb 2
from collections import namedtuple, deque
import heapq
from aocutils.common import multidict
from aocutils.common import to_int
from collections import defaultdict
from itertools import chain, product

# %% ../02_maze.ipynb 3
def graphparse(filename, parser=None, weights = False):
    f = open(filename, 'r').read().splitlines()
    if not parser:
        conn = [(line.split()) for line in f]
    else:
        if not weights:
            conn = [parser(line) for line in f]    
        else:
            conn = []
            for line in f:
                # a b 12
                x, y, weight = parser(line)
                conn.append((x, (y, weight)))
    return multidict(conn)


# %% ../02_maze.ipynb 5
def bfs(connections, start, goal=None, verbose=False):
    """
    Requires a connections dict with tuples with neighbors per node.
    Or a connections function returning neighbors per node

    Returns
    if goal == None:    return dict of locations with neighbor closest to start
    elif goal found:    returns path to goal
    else:               returns False
    """
    seen = set() # the locations that have been explored
    frontier = deque([start]) # the locations that still need to be visited
    # paths = {start: [start]}
    isfunction = callable(connections)
    parents = {start: None}

    def get_path(parents,start,goal):
        # print(start,goals)
        cur = goal
        path = [cur]
        while cur != start:
            cur = parents[cur]
            path.append(cur)
        path.reverse()
        return path

    while frontier:
        search = frontier.popleft()
        if isfunction: neighbors = connections(search)
        else: neighbors = connections.get(search,None)
        if neighbors:
            for n in neighbors:
                if n not in seen:
                    seen.add(n)
                    frontier.append(n)
                    # paths[n] = paths[search]+[n]
                    parents[n]= search
                    if goal and n == goal:
                        # print('goal found')
                        return get_path(parents,start,goal)
                        # return paths[goal],parents
        seen.add(search)
    if goal: return False
    else: return parents

# %% ../02_maze.ipynb 7
def dijkstra(connections,start, goal=None):
    """
    Requires a dict with as values a LIST of tuples (neighbor, weight)
    Or a function returning a list of tuples with neighbors and weights per node

    Returns
    if goal == None:    return all paths from start
    elif goal found:    returns path to goal
    else:               returns False
    """
    seen = set() # the locations that have been explored
    frontier = [(0,start)] # the locations that still need to be visited
    isfunction = callable(connections)
    parents = {start: (None,0)}

    def get_path(parents):
        cur = goal
        path = [cur]
        cost = parents[cur][1]
        while cur != start:
            cur = parents[cur][0]
            path.append(cur)
        path.reverse()
        return path,cost

    while frontier:
        # print('\n\n',frontier,'\n',parents)
        search_cost, search_node = heapq.heappop(frontier)
        # print('looking for', search_node,search_cost)
        if search_node == goal: break
        if isfunction: neighbors = connections(search_node)
        else: neighbors = connections.get(search_node,None)
        if neighbors:
            for n in neighbors:
                # print('n',n)
                if n[0] not in parents or n[1]+ search_cost < parents[n[0]][1]:
                    # print('updating')
                    heapq.heappush(frontier,(search_cost+n[1],n[0]))
                    # paths[n] = paths[search_node]+[n]
                    parents[n[0]]= (search_node,search_cost+n[1])
                        # return paths[goal],parents
        seen.add(search_node)
    if goal is None: return parents
    elif goal in parents: return get_path(parents)
    else: return False


# %% ../02_maze.ipynb 8
def distances(edges, directional = False):
    # implements floyd-warshall. If no weights are submitted, edges are considered 1
    # returns a dictionary with edges: distance
    # edges if length 0 are removed
    edges = list(edges)
    dis = defaultdict(lambda: float('inf'))
    if len(edges[0]) == 2:
        for i,j in edges:
            dis[i,j] = 1
            if not directional:
                dis[j,i] = 1
    else:
        for i,j,d in edges:
            dis[i,j] = d
            if not directional:
                dis[j,i] = d
    
    nodes = set(chain.from_iterable(edges))
    for n in nodes:
        dis[n,n] = 0
    for k,i,j in product(nodes, repeat=3):
        dis[i,j] = min(dis[i,j], dis[i,k] + dis[k,j])
    
    return {edge: d for edge, d in dis.items() if edge[0] != edge[1] and d != 0 and d != float('inf')}



# %% ../02_maze.ipynb 12
def get_path(parents,start,goal):
    # print(start,goals)
    cur = goal
    path = [cur]
    while cur != start:
        cur = parents[cur]
        path.append(cur)
    path.reverse()
    return path

# %% ../02_maze.ipynb 13
# found this on internet
def dfs(graph, start):
    visited, stack = set(), [start]
    while stack:
        vertex = stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            stack.extend(graph[vertex] - visited)
    return visited
