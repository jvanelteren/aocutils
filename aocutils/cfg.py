# AUTOGENERATED! DO NOT EDIT! File to edit: ../06_context_free_grammar.ipynb.

# %% auto 0
__all__ = ['CFG']

# %% ../06_context_free_grammar.ipynb 2
from collections import defaultdict
from itertools import product
import re


# %% ../06_context_free_grammar.ipynb 3
class CFG():
    """Takes a grammer as dict with tuple of options as values. Terminal values should not be in a tuple but as a string
    Usage:
        cfg = CFG(grammar_dict)
            reverse as optional parameter when k,v are reversed
            converts the grammar to Chomsky Normal form by taking care of options, unit productions and triplets
        cfg.solve(messages_list) returns dict of substrings with possible rules to make them
    """
    def __init__(self, grammar, terminals = None):
        self.outcomes = defaultdict(set)
        self.extra = 1
        if not terminals:
            print('no terminals specified!')
            sys.exit()
        self.terminals = terminals
        self.grammar = grammar
        # convert grammar to CNF and add terminals to outcomes
        self.grammar_to_cnf()
        assert all(isinstance(v, set) for k,v in self.grammar.items()), 'not all set'
        assert all(isinstance(option, tuple) for k,v in self.grammar.items() for option in v), 'not all tuples'
        assert all(isinstance(el, str) for k,v in self.grammar.items() for option in v for el in option), 'not all strings'
        assert  all(1 <= len(option) <=2 for k,v in self.grammar.items() for option in v), 'len not 1 or 2'
                    
        self.finalgrammar = defaultdict(set)
        for k,v in self.grammar.items():
            for option in v:
                self.finalgrammar[option].add(k)

        for t in self.terminals:
            if (t,) in self.finalgrammar:
                self.outcomes[t] = self.finalgrammar[(t,)]


        print('outcomes after grammar', self.outcomes)
                


    def grammar_to_cnf(self):
        self.grammar = self.to_cnf_remove_options(self.grammar)
        # eliminate unit rules
        self.grammar = self.to_cnf_remove_triplets(self.grammar)
        self.grammar = self.to_cnf_remove_unit_productions(self.grammar)

    def to_cnf_remove_options(self, grammar):
        # if reverse change from X : AB to AB : {X}
        # if there are options, these are given a separate entry, e.g.
        # X : (AB, CD) --> X: AB and X: CD
        new_grammar = defaultdict(set)
        
        for k,v in grammar.items():
            for option in v:
                print(k,v, 'option', option)
                new_grammar[k].add(option)
        return new_grammar
        
    def to_cnf_remove_triplets(self, grammar):
        # reduces triplets or larger to pairs
        # changes X : ABC to
        # X: AY, Y = BC
        new_grammar = defaultdict(set)
        for k,v in grammar.items():
            for option in v:
                if len(option) > 2:
                    option = list(option)
                    while len(option) > 2:
                        new_grammar['extra' + str(self.extra)].add(tuple(option[1:3]))
                        option[1:3] = ['extra' + str(self.extra)]
                        self.extra += 1
                    new_grammar[k].add(tuple(option))                    
                else:
                    new_grammar[k].add(option)
        return new_grammar
           
    
    def to_cnf_remove_unit_productions(self,grammar):
        # step to get to Chomsky Normal Form
        # if X : A, duplicate all A : Y with X : Y
        found = True
        while found:
            found = False
            for k,v in grammar.items():
                to_remove = set()
                singulars = {option[0] for option in v if len(option) == 1 and option[0] not in self.terminals}
                if singulars:
                    found = True
                grammar[k] = {option for option in grammar[k] if len(option) != 1 or option[0] not in singulars}
                for singular in singulars:
                    grammar[k] |= grammar[singular]
                        
        return grammar

    def pieces(self, test,l):
        # gets all possibilities of len l out of a string
        assert isinstance(test, str)
        return {test[i:i+l] for i in range(len(test)-l+1) if test[i:i+l] not in self.outcomes}

    def splitter(self,option):
        # splits string into all options of two substrings
        assert isinstance(option, str)
        return {(option[:i], option[i:]) for i in range(1,len(option))}

    def check_possible_option(self, option):
        first = self.outcomes.get(option[0],set())
        second = self.outcomes.get(option[1],set())
        res = set()
        for potential in product(first,second):
            # print('            this is a potential', potential)
            if potential in self.finalgrammar:
                # print('             and found!')
                res |= self.finalgrammar[potential]

        return res

    def solve(self, messages):
        # takes a list of messages and returns all possibilities for the substrings of m
        # print(self.outcomes)
        for num, m in enumerate(messages):
            # print(m, len(m))
            if num % 100 == 0: print(num*10, 'messages done')
            for i in range(1,len(m)+1):
                # print(i)
                for j in self.pieces(m, i):
                    # print('  ' + j)
                    for k in self.splitter(j):
                        # print('    ', k)
                        res = self.check_possible_option(k)
                        if res:
                            # print('      yes')
                            self.outcomes[j] |= res # this was a bug
                            
        print('finished all messages, returning dict')
        return self.outcomes
          


