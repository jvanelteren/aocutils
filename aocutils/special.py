# AUTOGENERATED! DO NOT EDIT! File to edit: ../04_special.ipynb.

# %% auto 0
__all__ = ['md5', 'binarysearch', 'deduce_matches', 'find_pattern_in_iter', 'find_repeat', 'find_cycle']

# %% ../04_special.ipynb 3
import hashlib
from pathlib import Path
import networkx as nx
from collections import defaultdict
from dataclasses import dataclass

# %% ../04_special.ipynb 4
def md5(input):
    return hashlib.md5(input.encode('utf-8')).hexdigest()

# %% ../04_special.ipynb 6
def binarysearch(minim,maxim,function, flips_to_true=True, verbose=True): 
    """
     function needs to return a boolean whether the solution is ok
     this implementation is for function that starts with false for minim and flip to true
     for TTTTFFFF, pass set flips_to_true flag to false. This flag is important to set correct!
    """
    new = minim
    while True:
        new = (minim+maxim)//2
        if verbose: print(f'to_test: {new}, min {minim}, max {maxim} ', end=' ')
        res = function(new)
        if verbose: print('function returns', res)
        if not flips_to_true: res = not res
        if res:
            if new == maxim: # solution found
                if flips_to_true:
                    print('solution found',new)
                    return new
                else:
                    print('solution found',new-1)
                    return new-1
            maxim = new
        else: minim = new+1


# %% ../04_special.ipynb 8
def deduce_matches(input_dict, option_type=str):
    """
    Takes a dict with multiple keys that have one or more options
    The trick is to start with what you know: keys with one option and remove that option for the other keys
    Continuing that process leads to every key ending up with one option (hopefully)

    Assumes: the options are strings and stored in an interable
    """
    found = 0
    while found < len(input_dict):
        for k, v in input_dict.items():
            if not isinstance(v, option_type) and len(v) == 1: # found one
                to_rem = v.pop()
                input_dict[k] = to_rem
                found += 1
                for _ , v2 in input_dict.items(): # remove the item from other lists
                    if not isinstance(v2, option_type) and to_rem in v2:
                        v2.remove(to_rem)
    return input_dict

# %% ../04_special.ipynb 10
def find_pattern_in_iter(start_pattern, function, goal = None, n_iter=1000000000):
    """
        Returns when a SPECIFIED pattern has been found from a function
        If goal = None, then first time the start pattern shows up again is returned
        Returns steps, pattern
    """
    if not goal: goal = start_pattern
    current = start_pattern
    for i in range(1,n_iter):
        current = function(current)
        # print(current)
        if current == goal:
            print(f'At step {i}, goal: {current} was found')
            return i, current

# %% ../04_special.ipynb 11
def find_repeat(start_pattern, function, n_iter=None):
    """
        Returns when a NONSPECFIED repeating pattern has been found
        Returns steps, pattern
    """
    if not n_iter: n_iter = round(10e20)
    seen = {start_pattern}
    current = start_pattern
    for i in range(1,n_iter):
        current = function(current)
        # print(current)
        if current in seen:
            print(f'Repeat was found at step {i}. Pattern: {current}')
            return i,current
        seen.add(current)

# %% ../04_special.ipynb 12
def find_cycle(start_pattern, function):
    """
        Find cycle length of some repeating pattern, by first inspecting which item repeats when
        And subtracting the time the item was first seen
    """
    step_second, pattern = find_repeat(start_pattern, function)
    step_first, pattern = find_pattern_in_iter(start_pattern, function, goal = pattern)
    return step_second - step_first
